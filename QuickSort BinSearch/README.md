# Quick Sort and Binary Search

В этой задаче вам предстоит реализовать алгоритм быстрой сортировки массива и написать процедуру сортировки

```pascal
procedure QSort(var a: array_t, N : integer);
```
и функцию бинарного поиска

```pascal
function BinSearch(var a: array_t; N, value: integer): integer;
```
Процедура `QSort` должна представлять из себя чистую реализацию алгоритма быстрой сортировки (который можно найти в ссылках ниже). Процедура должна сортировать уже имеющийся массив `a` длины `N`. Функция `BinSearch` реализует стандартный алгоритм бинарного поиска значения `value` в отсортированном массиве `a` длины `N` и возвращает индекс *самого первого вхождения*. Все массивы номеруются от 1 и до некоторой какого-то числа N. В случае, если элемента в массиве нет, `BinSearch` должна возвращать 0.

### Полезные ссылки
* [https://ru.wikipedia.org/wiki/quick_sort](https://ru.wikipedia.org/wiki/%D0%91%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)
* [https://ru.wikipedia.org/wiki/binary_search](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA)
* http://cppalgo.blogspot.ru/2010/07/binarysearch-lowerbound-upperbound.html

## Testing Quick Sort

В этой части задания требуется написать функцию `test`, инкапсулирующую в себе всю логику тестирования. В ней обязательно должны быть описаны известные assert-функции `ASSERT_EQ`, `ASSERT_TRUE`, `ASSERT_FALSE`. В тестах обязательно должны проверяться:
* случай `empty` нулевого массива;
* случай `one_element` с массивом из одного элемента;
* случай `tiny` с массивами из 2 и 3 элементов;
* случай `correctness`, который просто преверяет функцию на каких-то массивах различной длины (должны быть отдельно прописаны случаи только положительных элементов, только отрицательных и смешанный случай);
* случай `big_stress` который проверяет работу функции на массиве из 10000 элементов, заполненных случайными значениями из интервала (`-MaxInt`, `MaxInt`). Возможно, для реализации этой проверки, будет удобно написать дополнительную булеву функцию `check_sorted`, которая проверяет массив на отсортированность.

## Testing Binary Search

Также требуется написать тесты для функции `BinSearch`. Можно дополнить ими уже имеющийся интерфейс функции `test`. В процессе тестирования должны проверяться следующие случаи:
* случай `empty` нулевого массива;
* случай `one_element` с массивом из одного элемента;
* случай `tiny_equal` с массивом из двух одинаковых элементов;
* случай `tiny` с массивом из двух различных элементов, с расположением искомого элемента как на первой позиции, так и на второй;
* случай `correctness`, который проверяет работу функции на массивах различной длины (обязательно проверить на массиве из одинаковых элементов, на массиве с повторящимся искомым элементом, остальные различные случаи и комбинации);
* случай `big_stress`, который проверит правильность работы функции на массиве из 10000 элементов, заполненных случайными значениями из интервала (`-MaxInt`, `MaxInt`). При проверке можно воспользоваться сначала уже написанной функцией сортировки `QSort`. 

Во всех тестах этого блока следует искать значения как существующих в массиве элементов, так и каких-то несуществующих. Чем больше будет проверено ситуаций, тем лучше. В программировании два этих алгоритма, пожалуй, самые ошибкоопасные. За креативную идею сценария, не рассмотренного здесь, последует плюс в карму :)