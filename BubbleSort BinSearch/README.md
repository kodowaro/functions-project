# Bubble Sort and Binary Search

В этой задаче вам предстоит реализовать алгоритм сортировки пузырьком массива и написать процедуру сортировки

```pascal
procedure BSort(var a: array_t; N: integer);
```
и функцию бинарного поиска

```pascal
function BinSearch(var a: array_t; N, elem: integer): integer;
```
Процедура `BSort` должна представлять из себя чистую реализацию *самого эффективного* алгоритма сортировки пузырьком (который можно найти в ссылках ниже). Процедура должна сортировать уже имеющийся массив `a` длины `N`. Функция `BinSearch` реализует стандартный алгоритм бинарного поиска значения `elem` в отсортированном массиве `a` длины `N` и возвращает индекс *самого первого вхождения*. Все массивы номеруются от 1 и до некоторой какого-то числа N. В случае, если элемента в массиве нет, `BinSearch` должна возвращать 0.

### Полезные ссылки
* [https://ru.wikipedia.org/wiki/bubble_sort](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%BF%D1%83%D0%B7%D1%8B%D1%80%D1%8C%D0%BA%D0%BE%D0%BC)
* [https://ru.wikipedia.org/wiki/binary_search](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA)
* http://cppalgo.blogspot.ru/2010/07/binarysearch-lowerbound-upperbound.html

## Testing Bubble Sort

В этой части задания требуется написать функцию `test`, инкапсулирующую в себе всю логику тестирования. В ней обязательно должны быть описаны известные assert-функции `ASSERT_EQ`, `ASSERT_TRUE`, `ASSERT_FALSE`. В тестах обязательно должны проверяться:
* случай `empty` нулевого массива;
* случай `one_element` с массивом из одного элемента;
* случай `tiny` с массивами из 2 и 3 элементов;
* случай `correctness`, который просто преверяет функцию на каких-то массивах различной длины (должны быть отдельно прописаны случаи только положительных элементов, только отрицательных и смешанный случай);
* случай `correctness_upsorted` на отсортированном по неубыванию массиве;
* случай `correctness_downsorted` на отсортированном по невозрастанию массиве;
* случай `big_stress` который проверяет работу функции на массиве из 5000 элементов, заполненных случайными значениями из интервала (`-MaxInt`, `MaxInt`). Возможно, для реализации этой проверки, будет удобно написать дополнительную булеву функцию `check_sorted`, которая проверяет массив на отсортированность. **Этот тест очень большой, но должен работать до 30 сек**.

## Testing Binary Search

Также требуется написать тесты для функции `BinSearch`. Можно дополнить ими уже имеющийся интерфейс функции `test`. В процессе тестирования должны проверяться следующие случаи:
* случай `empty` нулевого массива;
* случай `one_element` с массивом из одного элемента;
* случай `tiny_equal` с массивом из двух одинаковых элементов;
* случай `tiny` с массивом из двух различных элементов, с расположением искомого элемента как на первой позиции, так и на второй;
* случай `correctness`, который проверяет работу функции на массивах различной длины (обязательно проверить на массиве из одинаковых элементов, на массиве с повторящимся искомым элементом, остальные различные случаи и комбинации);
* случай `big_stress`, который проверит правильность работы функции на массиве из 5000 элементов, заполненных случайными значениями из интервала (`-MaxInt`, `MaxInt`). При проверке можно воспользоваться сначала уже написанной функцией сортировки `BSort`. 

Во всех тестах этого блока следует искать значения как существующих в массиве элементов, так и каких-то несуществующих. Чем больше будет проверено ситуаций, тем лучше. В программировании алгоритм двоичного поиска один из самых, пожалуй, ошибкоопасных. За креативную идею сценария, не рассмотренного здесь, последует плюс в карму :)
